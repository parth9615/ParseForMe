{
  "name": "stackman",
  "version": "0.2.3",
  "description": "Enhance an error stacktrace with code excerpts and other goodies",
  "main": "index.js",
  "dependencies": {
    "after-all": "^2.0.2",
    "stackback": "0.0.2"
  },
  "devDependencies": {
    "longjohn": "^0.2.4",
    "standard": "^4.3.1",
    "tape": "^4.0.0"
  },
  "scripts": {
    "test": "standard && tape test/test.js && tape test/longjohn.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/watson/stackman.git"
  },
  "keywords": [
    "v8",
    "stack",
    "stacktrace",
    "stackframe",
    "callsite",
    "debug",
    "log",
    "error",
    "trace"
  ],
  "author": {
    "name": "Thomas Watson Steen",
    "email": "w@tson.dk"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/watson/stackman/issues"
  },
  "homepage": "https://github.com/watson/stackman",
  "coordinates": [
    18.4786244,
    -69.9548324
  ],
  "readme": "# Stackman\n\nGive Stackman an error and he will give an array of stack frames with\nextremely detailed information for each frame in the stack trace.\n\nWith Stackman you get access to the actual source code and surrounding\nlines for where the error occurred, you get to know if it happened\ninside a 3rd party module, in Node.js or in your own code. For a full\nlist of information, check out the API below.\n\n[![Build status](https://travis-ci.org/watson/stackman.svg?branch=master)](https://travis-ci.org/watson/stackman)\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://github.com/feross/standard)\n\n## Install\n\n```\nnpm install stackman\n```\n\n## Basic usage\n\n```javascript\nvar stackman = require('stackman')();\n\nvar err = new Error('Oops!');\n\nstackman(err, function (stack) {\n  stack.frames.forEach(function (frame) {\n    // output: <example.js:3> var err = new Error('Oops!');\n    console.log('<%s:%s> %s',\n      frame.getFileName(),\n      frame.getLineNumber(),\n      frame.context.line);\n  });\n});\n```\n\n## Gotchas\n\n### `error.stack`\n\nThis works because V8 (the JavaScript engine behind Node.js) allows us\nto hook into the stack trace generator function before that stack trace\nis generated. It's triggered by accessing the `.stack` property on the\nError object, so please don't do that before parsing the error to\nstackman, else this will not work!\n\nIf you want to output the regular stack trace, just do so after parsing\nit to stackman:\n\n```javascript\n// first call stackman with the error\nstackman(err, ...);\n\n// then you can print out the stack trace\nconsole.log(err.stack);\n```\n\n## API\n\n### Module\n\nParse options to the main stackman function to customize the default\nbehavior:\n\n```javascript\nvar options = { context: 5 };\nvar stackman = require('stackman')(options);\n```\n\nOptions:\n\n- `context` - The lines of context to be loaded on each side of the callsite line (default: 7)\n\nThe `stackman` function takes two arguments:\n\n- `err` - the error to be parsed\n- `callback` - a callback which will be called with the a stack object when the parsing is completed\n\n#### The `stack` object:\n\nThe callback given to the `stackman` function is called with a stack\nobject when the parsing is completed. The `stack` object have two\nimportant properties:\n\n- `properties` - An object containing all the custom properties from the original error object (properties of type `object` and `function` are not included in this object)\n- `frames` - An array of stack-frames, also called callsite objects\n\n### Callsite\n\n#### Custom properties\n\n- `callsite.context.pre` - The lines before the main callsite line\n- `callsite.context.line` - The main callsite line\n- `callsite.context.post` - The lines after the main callsite line\n\n#### Custom methods\n\n- `callsite.getTypeNameSafely()` - A safer version of `callsite.getTypeName()` as this safely handles an exception that sometimes is thrown when using `\"use strict\"`. Otherwise it returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object's [[Class]] internal property\n- `callsite.getRelativeFileName()` - Returns a filename realtive to `process.cwd()`\n- `callsite.getFunctionNameSanitized()` - Guaranteed to always return the most meaningful function name. If none can be determined, the string `<anonymous>` will be returned\n- `callsite.getModuleName()` - Returns the name of the module if `isModule()` is true\n- `callsite.isApp()` - Is this inside the app? (i.e. not native, not node code and not a module inside the node_modules directory)\n- `callsite.isModule()` - Is this inside the node_modules directory?\n- `callsite.isNode()` - Is this inside node core?\n\n#### Methods inherited from V8\n\nThe follwoing methods are inherited from the [V8 stack trace\nAPI](https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).\n\n- `callsite.getThis()` - returns the value of this\n- `callsite.getTypeName()` - returns the type of this as a string. This is the name of the function stored in the constructor field of this, if available, otherwise the object's [[Class]] internal property.\n- `callsite.getFunction()` - returns the current function\n- `callsite.getFunctionName()` - returns the name of the current function, typically its name property. If a name property is not available an attempt will be made to try to infer a name from the function's context.\n- `callsite.getMethodName()` - returns the name of the property of this or one of its prototypes that holds the current function\n- `callsite.getFileName()` - if this function was defined in a script returns the name of the script\n- `callsite.getLineNumber()` - if this function was defined in a script returns the current line number\n- `callsite.getColumnNumber()` - if this function was defined in a script returns the current column number\n- `callsite.getEvalOrigin()` - if this function was created using a call to eval returns a CallSite object representing the location where eval was called\n- `callsite.isToplevel()` - is this a toplevel invocation, that is, is this the global object?\n- `callsite.isEval()` - does this call take place in code defined by a call to eval?\n- `callsite.isNative()` - is this call in native V8 code?\n- `callsite.isConstructor()` - is this a constructor call?\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "stackman@0.2.3",
  "_shasum": "d6b2818bd23e7df76d77ae82f6d5d4726d92ccc0",
  "_resolved": "https://registry.npmjs.org/stackman/-/stackman-0.2.3.tgz",
  "_from": "https://registry.npmjs.org/stackman/-/stackman-0.2.3.tgz"
}
