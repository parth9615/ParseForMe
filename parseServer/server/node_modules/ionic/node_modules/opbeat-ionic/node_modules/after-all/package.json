{
  "name": "after-all",
  "version": "2.0.2",
  "description": "Execute several async functions and get a callback when they are all done",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sorribas/after-all.git"
  },
  "scripts": {
    "test": "tape test",
    "sauce": "node test/sauce.js"
  },
  "author": {
    "name": "Eduardo Sorribas",
    "email": "eduardo@sorribas.org",
    "url": "http://sorribas.org/"
  },
  "license": "MIT",
  "devDependencies": {
    "brtapsauce": "^0.4.0",
    "tape": "^2.13.3"
  },
  "dependencies": {
    "once": "^1.3.0"
  },
  "readme": "# after-all\n\n[![build status](https://secure.travis-ci.org/sorribas/after-all.png)](http://travis-ci.org/sorribas/after-all)\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/after-all.svg)](https://saucelabs.com/u/after-all)\n\nCall several asynchronous functions and invoke a callback 'after all' of them are done.\n\n## Installation\n\nYou can install it with npm.\n\n```\nnpm install after-all\n```\n\n## Simple example\n\n```js\nvar afterAll = require('after-all');\n\nvar next = afterAll(function(err) {\n\tif (err) return console.log(err); // one of the asynchronous calls had an error\n\tconsole.log('Yay! Everything is done');\n});\n\n// The above inner function will only be called when all of these asynchronous calls are done\n\nsomeAsynchronousCall1({foo:'bar'}, next());\nsomeAsynchronousCall2({val:2}, next(function(err, res) {\n\t// If you want to do something with the returned value, you can pass a function\n\tif (err) return;\n\tconsole.log('This was returned: '+res);\n}));\n```\n\n## More complex example and sample use case\n\nImagine you have to create a dashboard page which has a list of customers\na list products, the total amount of sales and some more information.\n\nNow, the queries to get this information are independent, yet we tend to wait for\none to be finished to start the next. We may be able to increase the performance\nby starting some of this queries at the same time and waiting for the callbacks.\n\nWe can use after-all to do something like this.\n\n```js\n\napp.get('/dashboard.json', function(req, res) {\n  var resp = {};\n  var next = afterAll(function() {\n    res.end(resp);\n  });\n\n  db.findCustomers(next(function(err, docs) {\n    resp.customers = docs;\n  }));\n\n  var cb = next(); // wrapping the callback is optional\n  db.findProducts(function(err, docs) {\n    db.findProductsSales(function(sales) {\n      resp.products = docs;\n      resp.productsSales = sales;\n      cb();\n    });\n  });\n\n  db.findTodaySalesAmount(next(function(err, amount) {\n    resp.todaySales = amount;\n  }));\n\n  db.findLastMonthSalesAmount(next(function(err, amount) {\n    resp.lastMonthSales = amount;\n  }));\n});\n```\n\nAs you can see, passing a callback to the `next` function is optional and it can be\nuseful to not pass any when you are doing more than one sequetial async operations as\nin the example above.\n\nAlso notice that all the calls to `next` must be done on the same tick.\n\n## Error handling\n\nIf an error is passed as the first parameter to the `next` callback, the \nfinal callback will be called immediately and the error will be passed to\nit as the first argument.\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/sorribas/after-all/issues"
  },
  "homepage": "https://github.com/sorribas/after-all#readme",
  "_id": "after-all@2.0.2",
  "_shasum": "20300298ed6094b4c85c98e7c8ad4dca628f9f73",
  "_resolved": "https://registry.npmjs.org/after-all/-/after-all-2.0.2.tgz",
  "_from": "https://registry.npmjs.org/after-all/-/after-all-2.0.2.tgz"
}
